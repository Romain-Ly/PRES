

\subsection{Topologies virtualisées}
\label{sec:conce:topologiesvirt}


Nous allons simuler des topologies openFlow en utilisant mininet. Les
switchs seront virtualisés par open Vswitch (OVS) qui est installé par
défaut dans mininet. Pour utiliser le multi chemin, le noyau de MPTCP
sera compilé dans la machine virtuelle et chaque hôte sera configuré
de manière adéquate pour pouvoir utiliser MPTCP.

Nous créerons et testerons les topologies virtuelles grâce à l'API
python.


\subsubsection{Multi-chemins simple}
\label{subsubsec:conception:multcihemin}
La topologie simple est composé de deux hôtes et de N switchs. Les N
switchs composeront les N chemins disponibles. Cette topologie simple
servira principalement de test du fonctionnement de MPTCP.

\subsubsection{FatTree}
\label{subsubsec:conception:fatTree}


Afin de tester MPTCP de manière réaliste, nous avons simulé une
topologie FatTree, souvent utilisée dans les Datacenters qui sont les
premiers nécessiteux des performances offertes par MPTCP. Cette
topologie repose sur le principe d'établir plusieurs liens physiques
entre deux équipements réseau, en l'occurrence des switches. Tous les
switches du réseau ont le même nombre de ports; ils sont organisés par
couches : une couche \og coeur\fg{}, une couche \og frontière \fg{} et
une couche \og hôtes\fg{}. Les couches hôtes et coeur sont directement
connectées à la couche frontière, mais pas entre elles. Chaque switch
de la couche coeur est connecté à chaque switch de la couche frontière
par de multiples liens. Le nombre de ports disponibles sur les
switches coeurs est équitablement réparti entre chaque switch
frontière; ainsi, avec deux switches coeurs et quatre switches
frontières à 36 ports, on disposera de 9 liens entre chaque paire de
switches de couches différentes. Le reste des ports disponibles sur
les switches frontières sont utilisés pour y connecter les hôtes, à
raison d'un lien par hôte. Notons que deux équipement d'une même
couche ne sont jamais interconnectés.


\subsubsection{MPTCP vs TCP}
\label{subsubsec:conception:MPTCPvsTCP}

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.6\textwidth]{../figures/khalili.jpg}
  \caption{\textbf{Testbed MPTCP vs TCP\cite{pareto2013}}.}
  \label{fig:khalili}
\end{figure}

Pour déterminer les critères de l'ordonnanceur (celui par défaut, ou
l'OLIA) à respecter les principes de MPTCP (équitabilité avec les
utilisateurs TCP et performances supérieures à TCP), nous allons
reproduire le \emph{testbed} utilisé dans l'article de Khalili
(\fig{fig:khalili}).


Si nous pouvons reproduire les résultats obtenus par Khalili avec
notre configuration, nous reproduirons le cas avec N1 utilisateurs
MPTCP et N2 utilisateurs TCP (voir \fig{fig:khalili}).

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.4\textwidth]{../figures/khaliliB.jpg}
  \caption{\textbf{Testbed MPTCP vs TCP\cite{pareto2013}}. Les N1
    utilisateurs MPTCP (rouge) utilisent deux points d'accès pour se
    connecter à un serveur distant dont un qui est partagé avec les N2
    utilisateurs TCP (bleu).}
  \label{fig:khalili2}
\end{figure}

\subsection{Performances de MPTCP}
\label{sec:conce:perfMPTCP}

Pour mesurer les performances de MPTCP, nous allons faire varier les
propriétés de chaque sous-flots empruntés en modifiant les chemins de
manière asymétrique. Le but est de créer des conditions de stress
qu'on pourra tester à la volée avec les différents algorithmes gérant
MPTCP (celui par défaut, l'OLIA et le notre si celui-ci est
opérationnel) et sur les différents topologies virtuels construites.


Les contraintes appliquées auront comme critères la latence (critère
actuellement priviliégé par l'ordonnanceur pour les choix de
sous-flots), la capacité, le taux d'erreur, la gigue, etc. Nous
testerons quelle est l'influence de ces paramètres sur le choix des
sous-flots par l'ordonnanceur.

\subsection{Conception algorithme sécurité}
\label{sec:conc:algosec}

Le but est de rendre une connexion plus sécurisée par la complexité de
l'analyse des paquets de données échangés entre deux
utilisateurs. Nous chercherons à faire une méthode simple et non
performante pour efffectuer des tests et savoir comment MPTCP réagit
au nouvel algorithme de répartition des paquets dans les sous-flots
TCP. Cette méthode consiste à prendre le nombre de sous-flots total et
de répartir les paquets équitablement entre les sous-flots. Le débit
de chaque sous-flot correspondra au débit le plus faible des
sous-flots.  Cela reste une solution de l'objectif noté dans le cahier
des charges.

Néanmoins il sera nécessaire d'avoir un algorithme plus
intelligent. En effet, il est nécessaire d'avoir un meilleur
algorithme que celui expliqué ci-dessus car le débit serait bien plus
faible si un des chemins à un débit beaucoup plus faible ou s'il est
congestionné. Or même si nous voulons accroître la sécurité il est
préférable d'avoir au moins le débit d'une connexion TCP simple. Bien
sûr, la difficulté dans cette partie est de pouvoir adapter
l'ordonnanceur selon le nombre de sous-flots disponibles car s'il n'y
a pas de chemins différents et que l'on veut sécurisé la connexion,
cela n'est pas possible et, s'il n'y en a pas assez ou qui ne sont pas
suffisamment corrects, cela aurait des répercussions sur le débit mais
il pourrait y avoir une option pour que l'utilisateur fasse lui-même
ses propres choix selon ses besoins.



\subsection{Test de l'algorithme d'ordonnancement}
\label{sec:conc:ealgo}
L'écriture et le test de l'algorithme d'ordonnancement dans le noyau
linux peut s'avérer une tâche difficile en si peu de temps. Pour
tester la validité de notre algorithme d'ordonnancement, nous
réfléchissons à effectuer d'abord un \emph{proof of concept} en
utilisant directement python qui utilisera des fonctions de
\emph{callback} pour certaines fonctions du noyau nécessaire à
MPTCP. On utilisera alors UDP pour la transmission des données.
